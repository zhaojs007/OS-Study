要理解段页式管理机制的发展历程，得从早期的处理器的寻址方式说起。

一）直接寻址

    在处理器发展的早期阶段，Intel公司推出了第一款8位的处理器-8080，它的内存寻址的方式很是简单粗暴，程序都是通过硬编码的形式绝对定位到内存地址。那么这种情况下程序具有明显的缺点：可控性差、难以重
定位、难以维护等。

二）分段机制

    随后，Intel推出了另一款处理器8086，当时它的寻址空间可以达到1M，即地址总线扩展到了20位，2^20 = 1M，然而由于当时制造20位的寄存器比较困难，为了能在16位的寄存器的基础上寻址20位的地址空间，由此引入了一个重要的概念—段，本质上是将1M的内存分为16个64K的段，随后段的基地址存放在寄存器中进行管理和寻址。所以8086中分段机制的内存寻址为：
    段基址左移4位 + 段内偏移 = 物理地址

    为了很好的支持分段机制，8086处理器为程序使用的代码段、数据段、堆栈段分别提供了专门的16位寄存器用以保存这些段的段基址。CPU会根据不同的内存访问请求而选择不同的段寄存器：对于取指令请求，代码段寄存器CS会被使用，对于堆栈操作（push/pop）会使用堆栈段寄存器SS，而其他操作则使用的是数据段DS或额外的段ES，后来又增加了两个可以自由使用的段寄存器FS和GS。在此时，这种寻址模式是“实模式”，也就是段寄存器只是一个单纯的16位寄存器，而且操作寄存器的指令也不是特权指令。通过设置段寄存器和段内偏移，程序就可以访问整个物理内存，无安全性可言。

    现在看来，从当时分段机制设计的初衷来看，段寄存器的设计只是“缓兵之计”，设计的目的就是为了将地址空间从64K扩展到1M，仅此而已。然后后续“保护模式”的出现，为分段机制新增了更多的意义。是巧合还是设计之前有先见之明，这里不得而知。

三）保护模式

    到了80386问世的时候，工艺上有了很大的进步，386的ALU已经从16位变为32位，接下来的80486一直到Pentium系列虽然速度提高了几个数量级，但并没有本质的变化，所以被统称为i386结构。

    对于32位的CPU而言，只要地址总线位宽和数据总线位宽一致，就可以寻址到2^32=4GB的内存空间，这已经是足够使用的了，没有必要再使用段寄存器进行扩展。但这时Intel已经无法将段寄存器从产品中移除出去（因为根据兼容性的需要，段寄存器必须保留下来）。

    同时，由于技术的发展要求Intel在CPU中实现“保护模式”，即用户程序能够访问的空间范围必须受到限制，不再是任意空间范围。随后，Intel利用段寄存器实现其保护模式，把保护模式建立在段寄存器的基础上。
    
    对于段的描述也不再只是一个20位的基地址，而是全新地定义了“段描述项”。段描述项的结构如下：
    
    B31~B24(8 bit)	DES1(4 bit)	L19~L16(4 bit)
    DES2(8 bit)		  B23~B16(8 bit)
    B15~B0(16 bit)
    L15~L0(16 bit)
    
    每一行是16 bit，总共64位。

    DES1和DES2分别是一些描述信息，用于描述本段是代码段还是数据段等，以及读写权限等。B31~B0是段基址，L19~L0是段长度。

    通过DES信息来对应到相应的段，然后再通过段基址加段长度来保证用户程序的访问空间不会超出范围，从而实现“保护模式”。另外需要注意的是，段长度只有20bit，所能表示的空间范围最大为2^20 = 1M，而整个地址空间是2^32 =4G，这样看来段长度的位宽设计是有问题的。其实不然，在DES1中有一个bit用来表示段长度的单位，当它设置为1时，表示段的单位为4KB，这样1M * 4KB = 4GB，从而保证段描述项能够覆盖所有的地址空间范围。同时4KB也是一个页的大小，说明段的长度也是向页对齐的。

    另外，需要注意到一个地方。段描述项的设计结构别设计得不连续，不论是段基址还是段长度都是不连续的，被分为了两节。这样的设计其实是和80286的过度有关。上面的4行描述项结构去掉第一行后剩下的三行正是286的段描述项。286被设计成24位地址总线，所以段基址的位宽为24bit，段长度为16bit。在386的地址总线扩展为32位之后，还必须做兼容，所以只好在段描述项上进行添加额外信息。

    在386中，段寄存器还是16位，那么16位的段寄存器如何存下64位的段描述项？段描述项不再直接放到段寄存器中，而是放到内存中，系统中可以有很多个段描述项，这些项连续存放，共同构成一张表，16位的段寄存器里只是含有这张表的一个索引，存储了一种数据结构，用来索引存放在内存中的段描述项，结构如下：

    index(b15~b3)	TI(b2)	RPL(b1~b0)
  
    其中index是段描述表中的索引，用来指向表中的某一个段描述项。RPL表示权限，00最高，11最低。

    读到这里，是不是有一个疑惑，就是段描述表的基地址是谁提供的呢？为了解决这个问题，Intel设计了两个新的寄存器：GDTR(global descriptor table register)和LDTR(local descriptor table register),分别用来存储段描述符的基地址。段寄存器的TI位正是用于指示使用GDTR还是LDTR。TI=0是，表示指向GDTR，TI=1表示LDTR。（根据段描述符表中存放的是全局的还是进程私有的描述符，分为全局段描述符表GDT和局部段描述符表LDT）。

四）分页机制

    现在操作系统的发展要求CPU支持页式存储管理。分页机制的核心思想是将虚拟内存空间和物理内存空间划分成固定大小的小块。与分段机制相比，分页使用大量容量较小、但数量固定的内存区域，而不是少量容量较大、但大小可变的区域。从内存利用率的角度来说，分页机制具有更好的性能，同时能够减少外部内存碎片的数量。同时，由于一个页很小，就会存在数以万计的虚拟页到物理帧的映射需要被维护，这里的映射信息是需要额外被存放的，因此在实际使用分页机制的过程中，需要考虑页面映射的保存对于资源的消耗以及映射查找对于性能的损耗。很大程度上资源的消耗又和页表查找的方式关联。在32位系统中，使用二级页表就可以存放下来了，对于64位系统，需要采用4级页表才能保证性能。

    对于APP层次带来的好处：每一个进程都有自己的3G的私有进程空间（这里内存选0~4G说明，3G~4G是kernel地址空间），每一个进程都有自己的页表。kernel完成从虚拟页表到物理页表的映射，这样多个页表项可以映射到同一个物理页面，从而完成共享内存的实现（多个进程共享物理内存）。

    TLB：CPU的Memory management unit（MMU）通过cache最近使用的页面映射来加速地址转换。这个加速缓存被称之为translation lookaside buffer（TLB）。TLB也是一种组相连的结构。
